# Codebase Export for Claude
Generated on: Thu Jul 24 14:19:21 CEST 2025

## Project Structure
llm-game/
â”œâ”€â”€ public
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ assets
â”‚   â”œâ”€â”€ components
â”‚   â”‚   â””â”€â”€ GameCanvas.tsx
â”‚   â”œâ”€â”€ data
â”‚   â”‚   â”œâ”€â”€ enemies.ts
â”‚   â”‚   â”œâ”€â”€ gameLayout.ts
â”‚   â”‚   â”œâ”€â”€ itemPrices.ts
â”‚   â”‚   â”œâ”€â”€ npcs.ts
â”‚   â”‚   â””â”€â”€ treasures.ts
â”‚   â”œâ”€â”€ services
â”‚   â”‚   â””â”€â”€ llmService.ts
â”‚   â”œâ”€â”€ types
â”‚   â”‚   â””â”€â”€ GameTypes.ts
â”‚   â”œâ”€â”€ utils
â”‚   â”‚   â”œâ”€â”€ gameUtils.ts
â”‚   â”‚   â”œâ”€â”€ layoutUtils.ts
â”‚   â”‚   â””â”€â”€ proceduralPlacement.ts
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ main.tsx
â”‚   â””â”€â”€ vite-env.d.ts
â”œâ”€â”€ eslint.config.js
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ README.md
â”œâ”€â”€ tsconfig.app.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.node.json
â””â”€â”€ vite.config.ts

## Project Files


## File: ./types/GameTypes.ts
//ts

// ===== types/GameTypes.ts =====
export type Player = {
	x: number;
	y: number;
	size: number;
	health: number;
	maxHealth: number;
	experience: number;
	level: number;
	inventory: string[];
	gold: number;
}

export type NPC = {
	id: string;
	x: number;
	y: number;
	size: number;
	color: string;
	name: string;
	dialogue: string[];
	currentDialogue: number;
	type: string;
}

export type Enemy = {
	id: string;
	x: number;
	y: number;
	size: number;
	health: number;
	maxHealth: number;
	damage: number;
	color: string;
	name: string;
	personality: string;
	battleCries: string[];
	defeated: boolean;
}

export type Treasure = {
	id: string;
	x: number;
	y: number;
	size: number;
	item: string;
	collected: boolean;
}

export type ItemPrice = {
	[key: string]: number;
}

// ===== LAYOUT TYPES =====
export type NamedPosition = {
	x: number;
	y: number;
}

export type SpawnZone = {
	minX: number;
	maxX: number;
	minY: number;
	maxY: number;
	avoid: string[]; // Named positions to avoid
}

export type EntityPlacement = {
	id: string;
	position?: string | NamedPosition; // Named position or coordinates
	zone?: string; // Spawn zone for random placement
}

export type GameLayout = {
	name: string;
	playerSpawn: NamedPosition;
	npcs: EntityPlacement[];
	enemies: EntityPlacement[];
	treasures: EntityPlacement[];
}

export type MapMode = 'procedural' | 'configuration';



## File: ./utils/proceduralPlacement.ts
//ts


// ===== utils/proceduralPlacement.ts =====
type PlacementRule = {
  entityType: 'npc' | 'enemy' | 'treasure';
  minDistance?: number;
  maxDistance?: number;
  avoidTypes?: string[];
  preferredZones?: string[];
  density?: number; // entities per 100x100 area
}

type PlacementConstraint = {
  minDistanceFromPlayer: number;
  minDistanceBetweenEntities: number;
  safeZones: { x: number, y: number, radius: number }[];
  dangerZones: { x: number, y: number, radius: number }[];
}

export class ProceduralPlacer {
  private placedPositions: Array<{ x: number, y: number, type: string, id: string }> = [];
  
  constructor(
    private canvasWidth: number,
    private canvasHeight: number,
    private constraints: PlacementConstraint
  ) {}

  placeEntities(rules: PlacementRule[]): Record<string, { x: number, y: number }[]> {
    const result: Record<string, { x: number, y: number }[]> = {
      npcs: [],
      enemies: [],
      treasures: []
    };

    // Place NPCs first (they get priority for good spots)
    rules.filter(r => r.entityType === 'npc').forEach(rule => {
      const positions = this.generatePositions(rule);
      result.npcs.push(...positions);
    });

    // Then enemies
    rules.filter(r => r.entityType === 'enemy').forEach(rule => {
      const positions = this.generatePositions(rule);
      result.enemies.push(...positions);
    });

    // Finally treasures
    rules.filter(r => r.entityType === 'treasure').forEach(rule => {
      const positions = this.generatePositions(rule);
      result.treasures.push(...positions);
    });

    return result;
  }

  private generatePositions(rule: PlacementRule): { x: number, y: number }[] {
    const positions: { x: number, y: number }[] = [];
    const targetCount = this.calculateTargetCount(rule);
    
    let attempts = 0;
    const maxAttempts = targetCount * 10;

    while (positions.length < targetCount && attempts < maxAttempts) {
      const candidate = this.generateCandidate(rule);
      
      if (this.isValidPosition(candidate, rule)) {
        positions.push(candidate);
        this.placedPositions.push({
          ...candidate,
          type: rule.entityType,
          id: `${rule.entityType}_${positions.length}`
        });
      }
      
      attempts++;
    }

    return positions;
  }

  private calculateTargetCount(rule: PlacementRule): number {
    if (rule.density) {
      const area = this.canvasWidth * this.canvasHeight;
      return Math.floor((area / 10000) * rule.density);
    }
    
    // Default counts based on entity type
    switch (rule.entityType) {
      case 'npc': return 2;
      case 'enemy': return 4;
      case 'treasure': return 4;
      default: return 1;
    }
  }

  private generateCandidate(rule: PlacementRule): { x: number, y: number } {
    // If preferred zones are specified, bias towards them
    if (rule.preferredZones && rule.preferredZones.length > 0) {
      // For now, just use random placement
      // In a full implementation, you'd define zone boundaries
    }

    return {
      x: Math.random() * (this.canvasWidth - 100) + 50,
      y: Math.random() * (this.canvasHeight - 100) + 50
    };
  }

  private isValidPosition(pos: { x: number, y: number }, rule: PlacementRule): boolean {
    // Check minimum distance from player spawn
    const playerSpawn = { x: 50, y: 50 }; // Should be configurable
    const distanceFromPlayer = this.distance(pos, playerSpawn);
    if (distanceFromPlayer < this.constraints.minDistanceFromPlayer) {
      return false;
    }

    // Check safe zones (NPCs should be in safe zones, enemies should avoid them)
    const inSafeZone = this.constraints.safeZones.some(zone => 
      this.distance(pos, zone) < zone.radius
    );

    if (rule.entityType === 'npc' && !inSafeZone) {
      return false; // NPCs must be in safe zones
    }

    if (rule.entityType === 'enemy' && inSafeZone) {
      return false; // Enemies should avoid safe zones
    }

    // Check minimum distance from other entities
    const tooClose = this.placedPositions.some(placed => {
      const distance = this.distance(pos, placed);
      
      if (rule.avoidTypes && rule.avoidTypes.includes(placed.type)) {
        return distance < (rule.minDistance || 100);
      }
      
      return distance < this.constraints.minDistanceBetweenEntities;
    });

    return !tooClose;
  }

  private distance(a: { x: number, y: number }, b: { x: number, y: number }): number {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
  }
}



## File: ./utils/layoutUtils.ts
//ts
// ===== utils/layoutUtils.ts =====
import type { NamedPosition, SpawnZone, GameLayout, EntityPlacement } from '@/types/GameTypes';
import { namedPositions, spawnZones } from '@/data/gameLayout';

export class LayoutManager {
  static resolvePosition(
    placement: EntityPlacement, 
    canvasWidth: number = 800, 
    canvasHeight: number = 600
  ): NamedPosition {
    // If specific position is provided
    if (placement.position) {
      if (typeof placement.position === 'string') {
        // Named position
        const named = namedPositions[placement.position];
        if (!named) {
          console.warn(`Named position '${placement.position}' not found, using default`);
          return { x: 100, y: 100 };
        }
        return named;
      } else {
        // Direct coordinates
        return placement.position;
      }
    }

    // If spawn zone is specified
    if (placement.zone) {
      const zone = spawnZones[placement.zone];
      if (!zone) {
        console.warn(`Spawn zone '${placement.zone}' not found, using default`);
        return { x: 100, y: 100 };
      }
      return this.getRandomPositionInZone(zone);
    }

    // Fallback to random position
    return {
      x: Math.random() * (canvasWidth - 50) + 25,
      y: Math.random() * (canvasHeight - 50) + 25
    };
  }

  static getRandomPositionInZone(zone: SpawnZone): NamedPosition {
    const attempts = 10; // Try to avoid named positions
    
    for (let i = 0; i < attempts; i++) {
      const x = Math.random() * (zone.maxX - zone.minX) + zone.minX;
      const y = Math.random() * (zone.maxY - zone.minY) + zone.minY;
      
      // Check if this position conflicts with avoided positions
      const tooClose = zone.avoid.some(avoidName => {
        const avoidPos = namedPositions[avoidName];
        if (!avoidPos) return false;
        const distance = Math.sqrt((x - avoidPos.x) ** 2 + (y - avoidPos.y) ** 2);
        return distance < 60; // Minimum distance
      });
      
      if (!tooClose) {
        return { x, y };
      }
    }
    
    // If we can't find a good spot, just use the zone center
    return {
      x: (zone.minX + zone.maxX) / 2,
      y: (zone.minY + zone.maxY) / 2
    };
  }

  static applyLayout(layout: GameLayout): {
    playerSpawn: NamedPosition;
    npcPositions: Record<string, NamedPosition>;
    enemyPositions: Record<string, NamedPosition>;
    treasurePositions: Record<string, NamedPosition>;
  } {
    const npcPositions: Record<string, NamedPosition> = {};
    const enemyPositions: Record<string, NamedPosition> = {};
    const treasurePositions: Record<string, NamedPosition> = {};

    layout.npcs.forEach(npc => {
      npcPositions[npc.id] = this.resolvePosition(npc);
    });

    layout.enemies.forEach(enemy => {
      enemyPositions[enemy.id] = this.resolvePosition(enemy);
    });

    layout.treasures.forEach(treasure => {
      treasurePositions[treasure.id] = this.resolvePosition(treasure);
    });

    return {
      playerSpawn: layout.playerSpawn,
      npcPositions,
      enemyPositions,
      treasurePositions
    };
  }
}



## File: ./utils/gameUtils.ts
//ts
// ===== utils/gameUtils.ts =====
export const distance = (x1: number, y1: number, x2: number, y2: number): number => {
	return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
};

export const isNearEntity = (
	playerX: number,
	playerY: number,
	entityX: number,
	entityY: number,
	threshold: number = 35
): boolean => {
	return distance(playerX, playerY, entityX, entityY) < threshold;
};


## File: ./vite-env.d.ts
//ts
/// <reference types="vite/client" />



## File: ./data/npcs.ts
//ts
// ===== data/npcs.ts =====
import type { NPC } from '@/types/GameTypes';

export const NPC_SIZE = 20;

export const npcsData: NPC[] = [
	{
		id: "merchant",
		x: 200,
		y: 100,
		size: NPC_SIZE,
		color: "green",
		name: "Merchant",
		type: "trader",
		dialogue: [
			"Welcome, traveler! I buy and sell various items.",
			"I have wares if you have coin, or I can buy your treasures!",
			"Just tell me what you want to sell and I'll make an offer!",
		],
		currentDialogue: 0,
	},
	{
		id: "wizard",
		x: 600,
		y: 300,
		size: NPC_SIZE,
		color: "purple",
		name: "Wizard",
		type: "sage",
		dialogue: [
			"Ah, a young adventurer! The mystical energies are strong today.",
			"Magic flows through these lands like rivers of starlight.",
			"Beware the creatures ahead - they speak in riddles and rage.",
		],
		currentDialogue: 0,
	},
];

// NPCs without hardcoded positions
export const npcTemplates: Omit<NPC, 'x' | 'y'>[] = [
	{
		id: "merchant",
		size: NPC_SIZE,
		color: "green",
		name: "Merchant",
		type: "trader",
		dialogue: [
			"Welcome, traveler! I buy and sell various items.",
			"I have wares if you have coin, or I can buy your treasures!",
			"Just tell me what you want to sell and I'll make an offer!",
		],
		currentDialogue: 0,
	},
	{
		id: "wizard",
		size: NPC_SIZE,
		color: "purple",
		name: "Wizard",
		type: "sage",
		dialogue: [
			"Ah, a young adventurer! The mystical energies are strong today.",
			"Magic flows through these lands like rivers of starlight.",
			"Beware the creatures ahead - they speak in riddles and rage.",
		],
		currentDialogue: 0,
	},
];

// Factory function to create positioned NPCs
export const createNPCsFromLayout = (positions: Record<string, { x: number; y: number }>): NPC[] => {
  return npcTemplates.map(template => ({
    ...template,
    x: positions[template.id]?.x || 0,
    y: positions[template.id]?.y || 0,
  }));
};



## File: ./data/gameLayout.ts
//ts
// ===== data/gameLayout.ts =====
import type { GameLayout, SpawnZone, NamedPosition } from '@/types/GameTypes';

// Define named positions for key locations
export const namedPositions: Record<string, NamedPosition> = {
  merchantCorner: { x: 200, y: 100 },
  wizardTower: { x: 600, y: 300 },
  centerCourt: { x: 400, y: 300 },
  northGate: { x: 400, y: 50 },
  southGate: { x: 400, y: 550 },
  eastWall: { x: 750, y: 300 },
  westWall: { x: 50, y: 300 },
};

// Define spawn zones for random placement
export const spawnZones: Record<string, SpawnZone> = {
  enemyPatrol: {
    minX: 350, maxX: 650,
    minY: 150, maxY: 450,
    avoid: ['merchantCorner', 'wizardTower'] // Don't spawn near friendly NPCs
  },
  treasureScatter: {
    minX: 50, maxX: 750,
    minY: 50, maxY: 550,
    avoid: ['merchantCorner', 'wizardTower']
  },
  safeZone: {
    minX: 50, maxX: 350,
    minY: 50, maxY: 200,
    avoid: []
  }
};

// Layout configurations for different scenarios
export const gameLayouts: Record<string, GameLayout> = {
  default: {
    name: "Village Outskirts",
    playerSpawn: { x: 50, y: 50 },
    npcs: [
      { id: "merchant", position: "merchantCorner" },
      { id: "wizard", position: "wizardTower" }
    ],
    enemies: [
      { id: "goblin1", zone: "enemyPatrol" },
      { id: "orc1", zone: "enemyPatrol" },
      { id: "skeleton1", position: { x: 150, y: 450 } }, // Specific guard position
      { id: "troll1", zone: "enemyPatrol" }
    ],
    treasures: [
      { id: "chest1", zone: "treasureScatter" },
      { id: "chest2", zone: "treasureScatter" },
      { id: "chest3", position: "westWall" },
      { id: "chest4", zone: "safeZone" }
    ]
  },
  dungeon: {
    name: "Dark Dungeon",
    playerSpawn: { x: 100, y: 500 },
    npcs: [
      { id: "merchant", position: { x: 100, y: 450 } } // Merchant at dungeon entrance
    ],
    enemies: [
      { id: "goblin1", position: { x: 200, y: 300 } },
      { id: "skeleton1", position: { x: 400, y: 200 } },
      { id: "orc1", position: { x: 600, y: 400 } },
      { id: "troll1", position: { x: 700, y: 100 } } // Boss at the end
    ],
    treasures: [
      { id: "chest1", position: { x: 300, y: 150 } },
      { id: "chest2", position: { x: 750, y: 50 } }, // Treasure behind boss
      { id: "chest3", position: { x: 500, y: 300 } },
      { id: "chest4", position: { x: 150, y: 200 } }
    ]
  }
};






## File: ./data/treasures.ts
//ts
// ===== data/treasures.ts =====
import type { Treasure } from '@/types/GameTypes';

export const TREASURE_SIZE = 12;

export const treasuresData: Treasure[] = [
	{
		id: "chest1",
		x: 300,
		y: 350,
		size: TREASURE_SIZE,
		item: "Health Potion",
		collected: false,
	},
	{
		id: "chest2",
		x: 700,
		y: 150,
		size: TREASURE_SIZE,
		item: "Magic Sword",
		collected: false,
	},
	{
		id: "chest3",
		x: 100,
		y: 300,
		size: TREASURE_SIZE,
		item: "Ancient Rune",
		collected: false,
	},
	{
		id: "chest4",
		x: 550,
		y: 100,
		size: TREASURE_SIZE,
		item: "Silver Ring",
		collected: false,
	},
];

// Treasures without hardcoded positions
export const treasureTemplates: Omit<Treasure, 'x' | 'y'>[] = [
	{
		id: "chest1",
		size: TREASURE_SIZE,
		item: "Health Potion",
		collected: false,
	},
	{
		id: "chest2",
		size: TREASURE_SIZE,
		item: "Magic Sword",
		collected: false,
	},
	{
		id: "chest3",
		size: TREASURE_SIZE,
		item: "Ancient Rune",
		collected: false,
	},
	{
		id: "chest4",
		size: TREASURE_SIZE,
		item: "Silver Ring",
		collected: false,
	},
];

// Factory function to create positioned treasures
export const createTreasuresFromLayout = (positions: Record<string, { x: number; y: number }>): Treasure[] => {
  return treasureTemplates.map(template => ({
    ...template,
    x: positions[template.id]?.x || 0,
    y: positions[template.id]?.y || 0,
  }));
};



## File: ./data/itemPrices.ts
//ts
// ===== data/itemPrices.ts =====
import type { ItemPrice } from '../types/GameTypes';

export const itemPrices: ItemPrice = {
	"Magic Sword": 100,
	"Ancient Rune": 75,
	"Silver Ring": 50,
	"Health Potion": 25,
};


## File: ./data/enemies.ts
//ts
// ===== data/enemies.ts =====
import type { Enemy } from '@/types/GameTypes';

export const ENEMY_SIZE = 15;

export const enemiesData: Enemy[] = [
	{
		id: "goblin1",
		x: 400,
		y: 200,
		size: ENEMY_SIZE,
		health: 30,
		maxHealth: 30,
		damage: 10,
		color: "red",
		name: "Snarky Goblin",
		personality: "sarcastic and cowardly",
		battleCries: [
			"You think you can defeat me, weakling?",
			"I've seen stronger butterflies!",
			"My grandmother hits harder than you!",
			"Is that all you've got?",
			"You're making this too easy!",
		],
		defeated: false,
	},
	{
		id: "orc1",
		x: 500,
		y: 400,
		size: ENEMY_SIZE,
		health: 50,
		maxHealth: 50,
		damage: 15,
		color: "darkred",
		name: "Brutal Orc",
		personality: "aggressive and proud warrior",
		battleCries: [
			"FOR THE HORDE! You will fall before my might!",
			"Your bones will make excellent decorations!",
			"I feast on the fear of weaklings like you!",
			"You dare challenge an orc warrior?!",
			"Blood and glory! FIGHT ME!",
		],
		defeated: false,
	},
	{
		id: "skeleton1",
		x: 150,
		y: 450,
		size: ENEMY_SIZE,
		health: 25,
		maxHealth: 25,
		damage: 8,
		color: "lightgray",
		name: "Melancholy Skeleton",
		personality: "sad and philosophical undead",
		battleCries: [
			"*sigh* Another fight... why must we do this?",
			"In death, I find no peace, only endless conflict...",
			"We are all bones beneath the flesh, friend.",
			"Fighting is so tiresome... but I must persist.",
			"Do you ever wonder what lies beyond this existence?",
		],
		defeated: false,
	},
	{
		id: "troll1",
		x: 650,
		y: 450,
		size: ENEMY_SIZE,
		health: 80,
		maxHealth: 80,
		damage: 20,
		color: "darkgreen",
		name: "Dim-witted Troll",
		personality: "simple-minded but surprisingly wise",
		battleCries: [
			"Troll smash! But... why we fight again?",
			"Me strong! You... you okay little person?",
			"Troll confused. Fighting make head hurt.",
			"Maybe we be friends after? Troll lonely.",
			"Big stick go BONK! Sorry in advance!",
		],
		defeated: false,
	},
];

// Enemies without hardcoded positions
export const enemyTemplates: Omit<Enemy, 'x' | 'y'>[] = [
  {
    id: "goblin1",
    size: ENEMY_SIZE,
    health: 30,
    maxHealth: 30,
    damage: 10,
    color: "red",
    name: "Snarky Goblin",
    personality: "sarcastic and cowardly",
    battleCries: [
      "You think you can defeat me, weakling?",
      "I've seen stronger butterflies!",
      "My grandmother hits harder than you!",
      "Is that all you've got?",
      "You're making this too easy!",
    ],
    defeated: false,
  },
  {
    id: "orc1",
    size: ENEMY_SIZE,
    health: 50,
    maxHealth: 50,
    damage: 15,
    color: "darkred",
    name: "Brutal Orc",
    personality: "aggressive and proud warrior",
    battleCries: [
      "FOR THE HORDE! You will fall before my might!",
      "Your bones will make excellent decorations!",
      "I feast on the fear of weaklings like you!",
      "You dare challenge an orc warrior?!",
      "Blood and glory! FIGHT ME!",
    ],
    defeated: false,
  },
  {
    id: "skeleton1",
    size: ENEMY_SIZE,
    health: 25,
    maxHealth: 25,
    damage: 8,
    color: "lightgray",
    name: "Melancholy Skeleton",
    personality: "sad and philosophical undead",
    battleCries: [
      "*sigh* Another fight... why must we do this?",
      "In death, I find no peace, only endless conflict...",
      "We are all bones beneath the flesh, friend.",
      "Fighting is so tiresome... but I must persist.",
      "Do you ever wonder what lies beyond this existence?",
    ],
    defeated: false,
  },
  {
    id: "troll1",
    size: ENEMY_SIZE,
    health: 80,
    maxHealth: 80,
    damage: 20,
    color: "darkgreen",
    name: "Dim-witted Troll",
    personality: "simple-minded but surprisingly wise",
    battleCries: [
      "Troll smash! But... why we fight again?",
      "Me strong! You... you okay little person?",
      "Troll confused. Fighting make head hurt.",
      "Maybe we be friends after? Troll lonely.",
      "Big stick go BONK! Sorry in advance!",
    ],
    defeated: false,
  },
];

// Factory function to create positioned enemies
export const createEnemiesFromLayout = (positions: Record<string, { x: number; y: number }>): Enemy[] => {
  return enemyTemplates.map(template => ({
    ...template,
    x: positions[template.id]?.x || 0,
    y: positions[template.id]?.y || 0,
  }));
};



## File: ./services/llmService.ts
//ts
// ===== services/llmService.ts =====
import type { Player, Enemy } from '@/types/GameTypes';

// Use import.meta.env for Vite or fallback to default values
const API_URL = import.meta.env.VITE_LLM_API_URL;
const MODEL_NAME = import.meta.env.VITE_LLM_MODEL;

export class LLMService {
	static async sendToLLM(
		userInput: string, 
		npcName: string, 
		player: Player,
		npcType: string = ""
	): Promise<string> {
		try {
			let systemPrompt = "";

			if (npcType === "trader") {
				systemPrompt = `You are ${npcName}, a friendly merchant in a fantasy RPG world. You buy and sell items. The player has ${
					player.gold
				} gold and these items: ${player.inventory.join(", ") || "nothing"}. 
				Items you buy: Magic Sword (100g), Ancient Rune (75g), Silver Ring (50g), Health Potion (25g). 
				If they want to sell, tell them to say "sell [item name]" clearly. Keep responses 1-2 sentences and merchant-like. You're talking to a level ${
					player.level
				} adventurer.`;
			} else {
				systemPrompt = `You are ${npcName}, a ${
					npcType || "friendly"
				} NPC in a fantasy RPG world. Keep responses short (1-2 sentences) and in character. You're talking to a level ${
					player.level
				} adventurer with ${player.gold} gold.`;
			}

			const res = await fetch(API_URL, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					model: MODEL_NAME,
					messages: [
						{
							role: "system",
							content: systemPrompt,
						},
						{ role: "user", content: userInput },
					],
					temperature: 0.8,
					max_tokens: 80,
					stream: false,
				}),
			});

			const data = await res.json();
			return data.choices[0].message.content;
		} catch (error) {
			throw new Error("The NPC seems distracted...");
		}
	}

	static async sendEnemyToLLM(
		enemy: Enemy, 
		situation: "attack" | "defend" | "death"
	): Promise<string> {
		try {
			let situationPrompt = "";
			switch (situation) {
				case "attack":
					situationPrompt = "You are attacking the player. Be menacing but stay in character.";
					break;
				case "defend":
					situationPrompt = "You just took damage from the player. React to being hurt.";
					break;
				case "death":
					situationPrompt = "You are about to be defeated. Give a final dramatic statement.";
					break;
			}

			const res = await fetch(API_URL, {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					model: MODEL_NAME,
					messages: [
						{
							role: "system",
							content: `You are ${enemy.name}, a ${enemy.personality} enemy in an RPG battle. ${situationPrompt} Keep it to 1 short sentence, stay in character. Your health is ${enemy.health}/${enemy.maxHealth}.`,
						},
						{
							role: "user",
							content:
								situation === "attack"
									? "You attack!"
									: situation === "defend"
									? "You take damage!"
									: "You are defeated!",
						},
					],
					temperature: 0.9,
					max_tokens: 30,
					stream: false,
				}),
			});

			const data = await res.json();
			return data.choices[0].message.content;
		} catch (error) {
			// Fallback to predefined battle cries
			return enemy.battleCries[Math.floor(Math.random() * enemy.battleCries.length)];
		}
	}
}



## File: ./App.tsx
//tsx
import GameCanvas from "./components/GameCanvas";

function App() {
	return (
		<>
			<GameCanvas />
		</>
	);
}

export default App;



## File: ./main.tsx
//tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.tsx";

createRoot(document.getElementById("root")!).render(
	<StrictMode>
		<App />
	</StrictMode>
);



## File: ./components/GameCanvas.tsx
//tsx
// ===== components/GameCanvas.tsx =====
import { useEffect, useRef, useState, useCallback } from "react";
import type { Player, NPC, Enemy, Treasure, MapMode } from "@/types/GameTypes";
import { npcsData, createNPCsFromLayout, npcTemplates } from "@/data/npcs";
import {
	enemiesData,
	createEnemiesFromLayout,
	enemyTemplates,
} from "@/data/enemies";
import {
	treasuresData,
	createTreasuresFromLayout,
	treasureTemplates,
} from "@/data/treasures";
import { itemPrices } from "@/data/itemPrices";
import { gameLayouts } from "@/data/gameLayout";
import { LLMService } from "@/services/llmService";
import { isNearEntity } from "@/utils/gameUtils";
import { LayoutManager } from "@/utils/layoutUtils";
import { ProceduralPlacer } from "@/utils/proceduralPlacement";

// Game constants
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const PLAYER_SIZE = 20;

type PlacementRule = {
	entityType: "npc" | "enemy" | "treasure";
	minDistance?: number;
	maxDistance?: number;
	avoidTypes?: string[];
	preferredZones?: string[];
	density?: number;
};

export default function GameCanvas() {
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const animationRef = useRef<number>();

	// Map mode state
	const [mapMode, setMapMode] = useState<MapMode>("configuration");
	const [currentLayout, setCurrentLayout] = useState("default");

	// Game state
	const [player, setPlayer] = useState<Player>({
		x: 50,
		y: 50,
		size: PLAYER_SIZE,
		health: 100,
		maxHealth: 100,
		experience: 0,
		level: 1,
		inventory: [],
		gold: 50,
	});

	const [npcs, setNpcs] = useState<NPC[]>(npcsData);
	const [enemies, setEnemies] = useState<Enemy[]>(enemiesData);
	const [treasures, setTreasures] = useState<Treasure[]>(treasuresData);

	const [gameMessage, setGameMessage] = useState<string>("");
	const [showInventory, setShowInventory] = useState<boolean>(false);
	const [inCombat, setInCombat] = useState<Enemy | null>(null);
	const [enemyTalking, setEnemyTalking] = useState<boolean>(false);

	// Initialize game with selected map mode
	const initializeGame = useCallback(() => {
		if (mapMode === "procedural") {
			const placer = new ProceduralPlacer(CANVAS_WIDTH, CANVAS_HEIGHT, {
				minDistanceFromPlayer: 80,
				minDistanceBetweenEntities: 40,
				safeZones: [
					{ x: 200, y: 100, radius: 60 }, // Around merchant area
					{ x: 50, y: 50, radius: 80 }, // Player spawn area
				],
				dangerZones: [
					{ x: 400, y: 300, radius: 100 }, // Central battle area
				],
			});

			const rules: PlacementRule[] = [
				{
					entityType: "npc",
					minDistance: 150,
					avoidTypes: ["enemy"],
					density: 0.3,
				},
				{
					entityType: "enemy",
					minDistance: 60,
					avoidTypes: ["npc"],
					preferredZones: ["dangerZone"],
					density: 0.8,
				},
				{
					entityType: "treasure",
					minDistance: 80,
					density: 0.6,
				},
			];

			const positions = placer.placeEntities(rules);

			// Create positioned entities
			const positionedNPCs = npcTemplates
				.slice(0, positions.npcs.length)
				.map((template, index) => ({
					...template,
					x: positions.npcs[index].x,
					y: positions.npcs[index].y,
				}));

			const positionedEnemies = enemyTemplates
				.slice(0, positions.enemies.length)
				.map((template, index) => ({
					...template,
					x: positions.enemies[index].x,
					y: positions.enemies[index].y,
				}));

			const positionedTreasures = treasureTemplates
				.slice(0, positions.treasures.length)
				.map((template, index) => ({
					...template,
					x: positions.treasures[index].x,
					y: positions.treasures[index].y,
				}));

			setNpcs(positionedNPCs);
			setEnemies(positionedEnemies);
			setTreasures(positionedTreasures);
			setPlayer((prev) => ({ ...prev, x: 50, y: 50 }));
		} else {
			// Configuration-based positioning
			const layout = gameLayouts[currentLayout];
			if (!layout) {
				console.error(`Layout '${currentLayout}' not found`);
				return;
			}

			const layoutResult = LayoutManager.applyLayout(layout);

			// Create positioned entities from layout
			const positionedNPCs = createNPCsFromLayout(layoutResult.npcPositions);
			const positionedEnemies = createEnemiesFromLayout(
				layoutResult.enemyPositions
			);
			const positionedTreasures = createTreasuresFromLayout(
				layoutResult.treasurePositions
			);

			setNpcs(positionedNPCs);
			setEnemies(positionedEnemies);
			setTreasures(positionedTreasures);
			setPlayer((prev) => ({
				...prev,
				x: layoutResult.playerSpawn.x,
				y: layoutResult.playerSpawn.y,
			}));
		}
	}, [mapMode, currentLayout]);

	// Initialize game when map mode or layout changes
	useEffect(() => {
		initializeGame();
	}, [initializeGame]);

	// Enhanced LLM call function with merchant trading logic
	const sendToLLM = useCallback(
		async (userInput: string, npcName: string, npcType: string = "") => {
			try {
				if (npcType === "trader") {
					// Check if player is trying to sell something
					const sellMatch = userInput
						.toLowerCase()
						.match(
							/sell|trade|buy.*?(magic sword|ancient rune|silver ring|health potion)/i
						);
					if (sellMatch) {
						const itemToSell = player.inventory.find((item) =>
							item.toLowerCase().includes(sellMatch[1]?.toLowerCase() || "")
						);

						if (itemToSell && itemPrices[itemToSell]) {
							const price = itemPrices[itemToSell];
							setPlayer((prev) => ({
								...prev,
								inventory: prev.inventory.filter((item) => item !== itemToSell),
								gold: prev.gold + price,
							}));
							setGameMessage(
								`${npcName}: Excellent! I'll buy your ${itemToSell} for ${price} gold!`
							);
							setTimeout(() => setGameMessage(""), 15000);
							return;
						} else if (sellMatch[1]) {
							setGameMessage(
								`${npcName}: Sorry, I don't see that item in your inventory, or I don't buy that kind of item.`
							);
							setTimeout(() => setGameMessage(""), 15000);
							return;
						}
					}
				}

				const response = await LLMService.sendToLLM(
					userInput,
					npcName,
					player,
					npcType
				);
				setGameMessage(`${npcName}: ${response}`);
				setTimeout(() => setGameMessage(""), 15000);
			} catch (error) {
				setGameMessage("The NPC seems distracted...");
				setTimeout(() => setGameMessage(""), 3000);
			}
		},
		[player]
	);

	// Enhanced combat system with enemy dialogue
	const startCombat = useCallback(async (enemy: Enemy) => {
		setInCombat(enemy);
		setEnemyTalking(true);

		try {
			const battleCry = await LLMService.sendEnemyToLLM(enemy, "attack");
			setGameMessage(`${enemy.name}: ${battleCry}`);
		} catch (error) {
			setGameMessage(`${enemy.name}: ${enemy.battleCries[0]}`);
		}

		setTimeout(() => {
			setEnemyTalking(false);
		}, 3000);
	}, []);

	const attack = useCallback(async () => {
		if (!inCombat || enemyTalking) return;

		const damage = 20 + player.level * 5;
		const newEnemies = enemies.map((enemy) =>
			enemy.id === inCombat.id
				? { ...enemy, health: enemy.health - damage }
				: enemy
		);

		setEnemies(newEnemies);

		const updatedEnemy = newEnemies.find((e) => e.id === inCombat.id);
		if (updatedEnemy && updatedEnemy.health <= 0) {
			// Enemy defeated - final words
			setEnemyTalking(true);

			try {
				const deathCry = await LLMService.sendEnemyToLLM(updatedEnemy, "death");

				const expGained = 15 + updatedEnemy.damage;
				const goldGained = Math.floor(Math.random() * 20) + 10;

				setPlayer((prev) => ({
					...prev,
					experience: prev.experience + expGained,
					level:
						prev.experience + expGained >= prev.level * 100
							? prev.level + 1
							: prev.level,
					gold: prev.gold + goldGained,
				}));

				setEnemies((prev) =>
					prev.map((e) => (e.id === inCombat.id ? { ...e, defeated: true } : e))
				);

				setGameMessage(
					`${inCombat.name}: ${deathCry}\n\n${inCombat.name} defeated! Gained ${expGained} XP and ${goldGained} gold!`
				);
				setInCombat(null);
				setEnemyTalking(false);
			} catch (error) {
				setGameMessage(`${inCombat.name} defeated!`);
				setInCombat(null);
				setEnemyTalking(false);
			}
		} else if (updatedEnemy) {
			// Enemy takes damage and responds
			setEnemyTalking(true);

			try {
				const hurtResponse = await LLMService.sendEnemyToLLM(
					updatedEnemy,
					"defend"
				);

				setTimeout(async () => {
					// Enemy attacks back
					const enemyDamage = updatedEnemy.damage;
					setPlayer((prev) => ({
						...prev,
						health: Math.max(0, prev.health - enemyDamage),
					}));

					try {
						const attackResponse = await LLMService.sendEnemyToLLM(
							updatedEnemy,
							"attack"
						);
						setGameMessage(
							`You hit for ${damage} damage!\n${updatedEnemy.name}: ${hurtResponse}\n\n${updatedEnemy.name}: ${attackResponse}\n${updatedEnemy.name} hits you for ${enemyDamage}!`
						);
					} catch (error) {
						setGameMessage(
							`You hit for ${damage} damage!\n${updatedEnemy.name}: ${hurtResponse}\n${updatedEnemy.name} hits you for ${enemyDamage}!`
						);
					}
					setEnemyTalking(false);
				}, 2000);
			} catch (error) {
				setGameMessage(`You hit for ${damage} damage!`);
				setEnemyTalking(false);
			}
		}
	}, [inCombat, enemyTalking, enemies, player.level]);

	const flee = useCallback(() => {
		setInCombat(null);
		setEnemyTalking(false);
		setGameMessage("You fled from combat!");
		// Move player away
		setPlayer((prev) => ({
			...prev,
			x: Math.max(0, prev.x - 50),
			y: Math.max(0, prev.y - 50),
		}));
	}, []);

	// Treasure collection
	const collectTreasure = useCallback((treasure: Treasure) => {
		setTreasures((prev) =>
			prev.map((t) => (t.id === treasure.id ? { ...t, collected: true } : t))
		);

		setPlayer((prev) => ({
			...prev,
			inventory: [...prev.inventory, treasure.item],
		}));

		if (treasure.item === "Health Potion") {
			setPlayer((prev) => ({
				...prev,
				health: Math.min(prev.maxHealth, prev.health + 50),
			}));
			setGameMessage("Found Health Potion! Health restored!");
		} else {
			setGameMessage(
				`Found ${treasure.item}! It might be valuable to a merchant.`
			);
		}
	}, []);

	// Drawing functions
	const draw = useCallback(() => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		const ctx = canvas.getContext("2d");
		if (!ctx) return;

		// Clear canvas
		ctx.fillStyle = "#2d5016";
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// Draw grid pattern for ground
		ctx.strokeStyle = "#3d6026";
		ctx.lineWidth = 1;
		for (let x = 0; x < canvas.width; x += 40) {
			ctx.beginPath();
			ctx.moveTo(x, 0);
			ctx.lineTo(x, canvas.height);
			ctx.stroke();
		}
		for (let y = 0; y < canvas.height; y += 40) {
			ctx.beginPath();
			ctx.moveTo(0, y);
			ctx.lineTo(canvas.width, y);
			ctx.stroke();
		}

		// Draw player
		ctx.fillStyle = player.health <= 25 ? "orange" : "blue";
		ctx.fillRect(player.x, player.y, player.size, player.size);

		// Player name
		ctx.fillStyle = "white";
		ctx.font = "12px Arial";
		ctx.fillText(`Player (Lv.${player.level})`, player.x, player.y - 5);

		// Draw NPCs
		npcs.forEach((npc) => {
			ctx.fillStyle = npc.color;
			ctx.fillRect(npc.x, npc.y, npc.size, npc.size);

			ctx.fillStyle = "white";
			ctx.fillText(npc.name, npc.x, npc.y - 5);

			if (isNearEntity(player.x, player.y, npc.x, npc.y)) {
				ctx.fillStyle = "yellow";
				ctx.fillText("Press SPACE to talk", npc.x, npc.y + npc.size + 15);
			}
		});

		// Draw enemies (only if not defeated)
		enemies.forEach((enemy) => {
			if (!enemy.defeated) {
				ctx.fillStyle = enemy.color;
				ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);

				ctx.fillStyle = "white";
				ctx.fillText(`${enemy.name} (${enemy.health}HP)`, enemy.x, enemy.y - 5);

				if (isNearEntity(player.x, player.y, enemy.x, enemy.y, 40)) {
					ctx.fillStyle = "red";
					ctx.fillText("Press F to fight", enemy.x, enemy.y + enemy.size + 15);
				}
			}
		});

		// Draw treasures
		treasures.forEach((treasure) => {
			if (!treasure.collected) {
				ctx.fillStyle = "gold";
				ctx.fillRect(treasure.x, treasure.y, treasure.size, treasure.size);

				if (isNearEntity(player.x, player.y, treasure.x, treasure.y)) {
					ctx.fillStyle = "yellow";
					ctx.fillText(
						"Press E to collect",
						treasure.x,
						treasure.y + treasure.size + 15
					);
				}
			}
		});
	}, [player, npcs, enemies, treasures]);

	// Game loop
	useEffect(() => {
		const gameLoop = () => {
			draw();
			animationRef.current = requestAnimationFrame(gameLoop);
		};

		gameLoop();

		return () => {
			if (animationRef.current) {
				cancelAnimationFrame(animationRef.current);
			}
		};
	}, [draw]);

	// Input handling
	useEffect(() => {
		const handleKeyDown = (e: KeyboardEvent) => {
			if (inCombat && (e.key === "1" || e.key === "2")) {
				if (e.key === "1" && !enemyTalking) attack();
				if (e.key === "2") flee();
				return;
			}

			const speed = 5;
			let newX = player.x;
			let newY = player.y;

			if (e.key === "ArrowUp" || e.key === "w") newY -= speed;
			if (e.key === "ArrowDown" || e.key === "s") newY += speed;
			if (e.key === "ArrowLeft" || e.key === "a") newX -= speed;
			if (e.key === "ArrowRight" || e.key === "d") newX += speed;

			// Boundary checking
			newX = Math.max(0, Math.min(CANVAS_WIDTH - player.size, newX));
			newY = Math.max(0, Math.min(CANVAS_HEIGHT - player.size, newY));

			setPlayer((prev) => ({ ...prev, x: newX, y: newY }));

			// Interactions
			if (e.key === " ") {
				const nearbyNPC = npcs.find((npc) =>
					isNearEntity(player.x, player.y, npc.x, npc.y)
				);
				if (nearbyNPC) {
					const userInput = prompt(`Talk to ${nearbyNPC.name}:`);
					if (userInput) sendToLLM(userInput, nearbyNPC.name, nearbyNPC.type);
				}
			}

			if (e.key === "f" || e.key === "F") {
				const nearbyEnemy = enemies.find(
					(enemy) =>
						!enemy.defeated &&
						isNearEntity(player.x, player.y, enemy.x, enemy.y, 40)
				);
				if (nearbyEnemy && !inCombat) {
					startCombat(nearbyEnemy);
				}
			}

			if (e.key === "e" || e.key === "E") {
				const nearbyTreasure = treasures.find(
					(treasure) =>
						!treasure.collected &&
						isNearEntity(player.x, player.y, treasure.x, treasure.y)
				);
				if (nearbyTreasure) {
					collectTreasure(nearbyTreasure);
				}
			}

			if (e.key === "i" || e.key === "I") {
				setShowInventory(!showInventory);
			}
		};

		document.addEventListener("keydown", handleKeyDown);
		return () => document.removeEventListener("keydown", handleKeyDown);
	}, [
		player,
		npcs,
		enemies,
		treasures,
		inCombat,
		showInventory,
		enemyTalking,
		sendToLLM,
		startCombat,
		attack,
		flee,
		collectTreasure,
	]);

	return (
		<div
			className="game-container"
			style={{ position: "relative", display: "inline-block" }}
		>
			{/* Map Mode Controls */}
			<div
				style={{
					position: "absolute",
					top: "-60px",
					left: "0px",
					background: "rgba(0,0,0,0.8)",
					color: "white",
					padding: "10px",
					borderRadius: "5px",
					display: "flex",
					gap: "10px",
					alignItems: "center",
				}}
			>
				<label>
					<input
						type="radio"
						value="configuration"
						checked={mapMode === "configuration"}
						onChange={(e) => setMapMode(e.target.value as MapMode)}
					/>
					Configuration-Based
				</label>
				<label>
					<input
						type="radio"
						value="procedural"
						checked={mapMode === "procedural"}
						onChange={(e) => setMapMode(e.target.value as MapMode)}
					/>
					Procedural
				</label>
				{mapMode === "configuration" && (
					<select
						value={currentLayout}
						onChange={(e) => setCurrentLayout(e.target.value)}
						style={{ marginLeft: "10px", padding: "5px" }}
					>
						<option value="default">Village Outskirts</option>
						<option value="dungeon">Dark Dungeon</option>
					</select>
				)}
				<button
					onClick={initializeGame}
					style={{
						marginLeft: "10px",
						padding: "5px 10px",
						backgroundColor: "#4CAF50",
						color: "white",
						border: "none",
						borderRadius: "3px",
						cursor: "pointer",
					}}
				>
					Reset Map
				</button>
			</div>

			<canvas
				ref={canvasRef}
				width={CANVAS_WIDTH}
				height={CANVAS_HEIGHT}
				style={{ border: "2px solid #333", backgroundColor: "#2d5016" }}
			/>

			{/* UI Overlay */}
			<div
				style={{
					position: "absolute",
					top: "10px",
					left: "10px",
					background: "rgba(0,0,0,0.8)",
					color: "white",
					padding: "10px",
					borderRadius: "5px",
					fontFamily: "monospace",
				}}
			>
				<div>
					Mode:{" "}
					{mapMode === "procedural"
						? "Procedural"
						: `Config (${currentLayout})`}
				</div>
				<div>Level: {player.level}</div>
				<div>
					Health: {player.health}/{player.maxHealth}
				</div>
				<div>XP: {player.experience}</div>
				<div>Next Level: {player.level * 100}</div>
				<div style={{ color: "gold" }}>Gold: {player.gold}</div>
			</div>

			{/* Combat UI */}
			{inCombat && (
				<div
					style={{
						position: "absolute",
						top: "50%",
						left: "50%",
						transform: "translate(-50%, -50%)",
						background: "rgba(0,0,0,0.9)",
						color: "white",
						padding: "20px",
						borderRadius: "10px",
						textAlign: "center",
					}}
				>
					<h3>Combat: {inCombat.name}</h3>
					<p>
						Enemy Health: {inCombat.health}/{inCombat.maxHealth}
					</p>
					<div>
						<button
							onClick={attack}
							disabled={enemyTalking}
							style={{
								margin: "5px",
								padding: "10px",
								opacity: enemyTalking ? 0.5 : 1,
							}}
						>
							1 - Attack {enemyTalking ? "(Wait...)" : ""}
						</button>
						<button onClick={flee} style={{ margin: "5px", padding: "10px" }}>
							2 - Flee
						</button>
					</div>
					{enemyTalking && (
						<p style={{ color: "yellow", fontStyle: "italic" }}>
							{inCombat.name} is speaking...
						</p>
					)}
				</div>
			)}

			{/* Inventory */}
			{showInventory && (
				<div
					style={{
						position: "absolute",
						top: "10px",
						right: "10px",
						background: "rgba(0,0,0,0.8)",
						color: "white",
						padding: "10px",
						borderRadius: "5px",
						minWidth: "200px",
					}}
				>
					<h4>Inventory (Press I to close)</h4>
					<div style={{ color: "gold", marginBottom: "10px" }}>
						Gold: {player.gold}
					</div>
					{player.inventory.length === 0 ? (
						<p>Empty</p>
					) : (
						<div>
							{player.inventory.map((item, index) => (
								<div key={index} style={{ marginBottom: "5px" }}>
									{item}
									{itemPrices[item] && (
										<span style={{ color: "gold", fontSize: "10px" }}>
											{" "}
											(Worth {itemPrices[item]}g)
										</span>
									)}
								</div>
							))}
							<div
								style={{
									marginTop: "10px",
									fontSize: "12px",
									color: "lightblue",
								}}
							>
								ðŸ’¡ Tell the Merchant "sell [item name]" to trade!
							</div>
						</div>
					)}
				</div>
			)}

			{/* Game Messages */}
			{gameMessage && (
				<div
					style={{
						position: "absolute",
						bottom: "60px",
						left: "50%",
						transform: "translateX(-50%)",
						background: "rgba(0,0,0,0.9)",
						color: "white",
						padding: "15px",
						borderRadius: "10px",
						maxWidth: "500px",
						textAlign: "center",
						whiteSpace: "pre-line",
						border: "2px solid #444",
					}}
				>
					{gameMessage}
				</div>
			)}

			{/* Controls */}
			<div
				style={{
					position: "absolute",
					bottom: "10px",
					right: "10px",
					background: "rgba(0,0,0,0.8)",
					color: "white",
					padding: "10px",
					borderRadius: "5px",
					fontSize: "12px",
				}}
			>
				<div>WASD/Arrows: Move</div>
				<div>Space: Talk to NPC</div>
				<div>F: Fight enemy</div>
				<div>E: Collect treasure</div>
				<div>I: Toggle inventory</div>
			</div>
		</div>
	);
}


